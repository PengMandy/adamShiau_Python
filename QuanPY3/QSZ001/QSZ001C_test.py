import cv2
import numpy as np 
import pyqtgraph as pg 
from PyQt5.QtCore import *
import matplotlib.pyplot as plt 
import time
import logging

HEIGHT = 1024
WIDTH = 1024
INTENSITY_LOW = 90

class TestImage():
	def __init__(self, fname):
		self.imglist =[]
		self.fp = open(fname,"w")
		self.loggername = "TEST"
		self.logger = logging.getLogger(self.loggername)

	def generateImage(self, photoindex, index, variation, rate, maxarea, newimg, ratefixed):
		img_number = 2* maxarea
		self.img = np.zeros((HEIGHT, WIDTH,), np.uint8)
		repeat_photoindex =0
		if not newimg:
			for j in range(len(self.imglist)):
				if self.imglist[j][0]== photoindex:
					repeat_photoindex = j
			# print(repeat_photoindex)
		# init image with random background
		for i in range(0, HEIGHT):
			for j in range(0, WIDTH):
				self.img[j][i] = np.random.random()*10+30
		# generate the bateria data including xpos, ypos and size
		
		# If new image is needed, set newimg = True, xpos, ypos and size will be 
		# generated by random number generator.
		poslist = []
		self.fp.write(str(photoindex)+"\n")
		self.logger.debug("scan index = " + str(index))
		self.logger.debug("photo index = " + str(photoindex))
		# print("photo index = " + str(photoindex))

		for i in range(0, img_number):
			if newimg:
				xpos = int(np.random.random()*1024)
				ypos = int(np.random.random()*1024)
				size = int(np.random.random()*30)+10
				

		# if updated image is required, set newimg = False, the xpos, ypos and size
		# will be generated from the data in self.imglist with modifed tolorance and rate

			else:

				# print(self.imglist[repeat_photoindex][1])
				xpos = self.imglist[repeat_photoindex][1][i][0] + int(np.random.random()*variation)
				ypos = self.imglist[repeat_photoindex][1][i][1] + int(np.random.random()*variation)
				if ratefixed:
					size = int(self.imglist[repeat_photoindex][1][i][2]*np.exp(rate))
				else:
					rate = max(rate + (np.random.random()*0.3 -0.15),0)
					size = self.imglist[repeat_photoindex][1][i][0]*np.exp(rate)

			poslist.append([xpos, ypos, size])
			self.fp.write(str(xpos)+","+str(ypos)+","+str(size)+"\n")
			self.logger.debug(str(xpos)+","+str(ypos)+","+str(size))

			decrease = 0 
			while decrease < size:
				self.img =cv2.circle(self.img, (xpos,ypos), size-decrease, INTENSITY_LOW+decrease*2, 1)
				decrease = decrease+1
		self.imglist.append([photoindex, poslist])
		return self.img

if __name__ == '__main__':
	a = TestImage()
	variation = 50
	rate = 0.3
	maxarea = 3
	for photoindex in range(0, 4):
		a.generateImage(photoindex, 0, variation, rate, maxarea, True, True)
		plt.imshow(a.img)
		plt.title("photoindex="+str(photoindex))
		plt.show()

	for j in range(1, 5):
		a.generateImage(3, j, variation, rate, maxarea, False, True)
		plt.imshow(a.img)
		plt.title("index="+str(j))
		plt.show()
